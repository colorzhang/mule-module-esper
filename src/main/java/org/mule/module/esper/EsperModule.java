/**
 * Mule Development Kit
 * Copyright 2010-2011 (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file was automatically generated by the Mule Development Kit
 */
package org.mule.module.esper;

import com.espertech.esper.client.*;
import com.espertech.esper.event.bean.BeanEventBean;
import com.espertech.esper.event.map.MapEventBean;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.mule.api.ConnectionException;
import org.mule.api.MuleContext;
import org.mule.api.MuleMessage;
import org.mule.api.annotations.*;
import org.mule.api.annotations.param.Optional;
import org.mule.api.annotations.param.Payload;
import org.mule.api.callback.InterceptCallback;
import org.mule.api.callback.SourceCallback;
import org.mule.api.context.MuleContextAware;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;

/**
 * Mule Module for Esper.
 *
 * @author MuleSoft, Inc.
 */
@Module(name = "esper", schemaVersion = "1.0", poolable = false)
public class EsperModule implements MuleContextAware {

    protected transient Log logger = LogFactory.getLog(getClass());

    private EPServiceProvider esperServiceProvider;

    private MuleContext muleContext;

    private Map<String, EPStatement> filterStatements = new HashMap<String, EPStatement>();

    /**
     * The optional location of an Esper config file.
     */
    @Configurable
    @Optional
    private String configuration;


    public void setConfiguration(String configuration) {
        this.configuration = configuration;
    }


    public void setMuleContext(MuleContext muleContext) {
        this.muleContext = muleContext;
    }

    @PostConstruct
    public void connect() throws ConnectionException {
        Configuration c = new Configuration();

        if (StringUtils.isNotBlank(configuration)) {
            logger.debug("Initializing EsperServiceProvider with configuration: " + configuration);
            URL configURL = Thread.currentThread().getContextClassLoader().getResource(configuration);
            c.configure(configURL);
        }
        esperServiceProvider = EPServiceProviderManager.getDefaultProvider(c);
    }

    @PreDestroy
    public void disconnect() {
        logger.debug("Destroying EsperServiceProvider");
        esperServiceProvider.destroy();
    }

    /**
     * Sends events to an Esper event stream.
     * <p/>
     * {@sample.xml ../../../doc/Esper-connector.xml.sample esper:send-event}
     *
     * @param eventPayload The event to be injected into the event stream.
     */
    @Processor
    public void send(Object eventPayload) {
        logger.debug(String.format("Sending event %s to stream", eventPayload));
        esperServiceProvider.getEPRuntime().sendEvent(eventPayload);
    }

    /**
     * Listens for events matching the specified query statement.
     * <p/>
     * {@sample.xml ../../../doc/Esper-connector.xml.sample esper:listen}
     *
     * @param statement The Esper statement to select events from a stream.
     * @param callback  The callback to be called when a message is received
     */
    @Source
    public void listen(String statement, final SourceCallback callback) {
        logger.debug("Listening for events with statement: " + statement);
        EPStatement s = esperServiceProvider.getEPAdministrator().createEPL(statement);
        s.addListener(new SourceCallbackUpdateListener(callback));
    }


    /**
     * Filters messages that match the supplied EPL query.  The EPL query <b>must</b> return a Boolean
     * value.
     * <p/>
     * {@sample.xml ../../../doc/Esper-connector.xml.sample esper:filter}
     *
     * @param eventPayload The event to be injected into the event stream.
     * @param statement    the EPL statement
     * @param key          the key of the result to evaluate from the query
     * @param afterChain   the <code>SourceCallback</code>
     */
    @Processor(intercepting = true)
    public synchronized void filter(Object eventPayload, String statement, String key, InterceptCallback afterChain) {

        esperServiceProvider.getEPRuntime().sendEvent(eventPayload);

        EPStatement filterStatement;

        if (!filterStatements.containsKey(statement)) {
            filterStatement = esperServiceProvider.getEPAdministrator().createEPL(statement);
            filterStatements.put(statement, filterStatement);
        } else {
            filterStatement = filterStatements.get(statement);
        }

        SafeIterator<EventBean> safeIterator = filterStatement.safeIterator();

        try {
            //if (safeIterator.hasNext())
            //  System.out.println("\n\n\n\n\n RESULT: " + safeIterator.next().get(key));
            Boolean result = (Boolean) safeIterator.next().get(key);

            if (safeIterator.hasNext()) {
                logger.warn("Statement contains more then one response");
            }

            if (!result) {
                logger.debug("Not passing message, filter expression evaluated to true");
                afterChain.doNotContinue();
            }

        } catch (Exception e) {
            throw new EsperException(e);
        } finally {
            safeIterator.close();
        }

    }
}
